# This file is part of openrsp-numdiff-scripts.
# openrsp-numdiff-scripts is made available under an LGPL license.

import numpy as np
import copy
import os
from openrsp_tensor_reader import *

# This routine is from the SpectroscPy script package (https://gitlab.com/kdu002/SpectroscPy and https://pypi.org/project/SpectroscPy/) in verbatim or near-verbatim form. See README.md for more information.
# Read a(n) (LS)Dalton mol file and return the information needed to write a corresponding file later on with write_mol
def read_mol(fname):

	f = open(fname, 'r')
	
	start_of_atoms = 0

	coords = []
	charges_per_type = []

	nline = f.readline()

	# Basis set given on the second line
	basis_set = f.readline()

	num_atoms_per_type = []

	while not(start_of_atoms):

		nline = f.readline()
		
		start_of_atoms = re.search('atomtypes', nline, flags=re.I)

		if (start_of_atoms):

			num_atomtypes = int(re.search('\d+', nline).group())

	for i in range(num_atomtypes):

		nline = f.readline()

		re.search('atomtypes', nline, flags=re.I)
		curr_charge = int(re.sub('charge\s*\=\s*', '', re.search('charge\s*\=\s*\d+', nline, flags=re.I).group(), flags=re.I))
		curr_num_atoms = int(re.sub('atoms\s*\=\s*', '', re.search('atoms\s*\=\s*\d+', nline, flags=re.I).group(), flags=re.I))

		charges_per_type.append(curr_charge)
		num_atoms_per_type.append(curr_num_atoms)

		for j in range(curr_num_atoms):

			nline = f.readline().split()
			coords.append([float(k) for k in nline[1:]])

	return basis_set, num_atomtypes, num_atoms_per_type, charges_per_type, coords

# This routine is from or is inspired by code in the SpectroscPy script package (https://gitlab.com/kdu002/SpectroscPy and https://pypi.org/project/SpectroscPy/). See README.md for more information.
# Generate a(n) (LS)Dalton mol file fname based on provided information
# Will overwrite fname if it already exists
# Will use nosymmetry flag
# Coordinate units assumed to be bohr
def write_mol(fname, basis_set, num_atomtypes, num_atoms_per_type, charges_per_type, coords):

	# Overwrites the existing file
	f = open(fname, 'w')

	f.write('BASIS\n')
	f.write(basis_set)

	f.write('Mol file generated by write_mol routine\n')
	f.write('This line intentionally left blank\n')
	f.write('AtomTypes=' + str(num_atomtypes) + ' Nosymmetry\n')

	acc_atom = 0

	for i in range(num_atomtypes):

		f.write('Charge=' + str(charges_per_type[i]) + ' Atoms=' + str(num_atoms_per_type[i]) + '\n')
		
		for j in range(num_atoms_per_type[i]):

			# Atoms will be called A1, A2, A3, ...
			# Can be changed later on to dictionary-style lookup of atom name based on nuclear charge
			f.write('A' + str(acc_atom + 1) + ' ' + str(coords[acc_atom][0]) + ' ' + str(coords[acc_atom][1]) + ' ' + str(coords[acc_atom][2]) + '\n' )

			acc_atom += 1

	f.write('')

	return

# Take a mol and dal file and execute an (LSDalton with OpenRSP) binary fname_bin with basis set directory basdir
# Return the appropriate response tensor
def do_rsp_calc(fname_mol, fname_dal, fname_bin, basdir):

	os.system('cp ' + fname_mol + ' MOLECULE.INP')
	os.system('cp ' + fname_dal + ' LSDALTON.INP')

	os.system('export BASDIR=' + basdir)

	os.system(fname_bin)

	prop, tensor = read_orsp_tensor_file('rsp_tensor')

	return tensor[0]



# Do numerical differentiation and compare to reference data
# Input data: 
	# Template mol file fname_mol
	# Template lower-order dal file fname_dal
	# Result tensor from higher-order calculation fname_ref
	# Path to binary fname_bin
	# Path to basis set directory basdir
	# Stencil extent stencil_np to choose between various stencil formulas (currently 2-point and 7-point supported)
	# Displacement d to use for numerical differentiation (default = 0.001 bohr)
def perform_num_diff_and_compare(fname_mol, fname_dal, fname_ref, fname_bin, basdir, stencil_np, d=0.001):

	fname_mol_chg = 'numdiff_geo.mol'

	# Get reference property specification and tensor from reference file
	prop_ref, tensor_ref = read_orsp_tensor_file(fname_ref)
	tensor_ref = tensor_ref[0]

	# Get molecule information from mol file
	basis_set, num_atomtypes, num_atoms_per_type, charges_per_type, coords = read_mol(fname_mol)
	# Set up zeroed comparison tensor to be filled with num diff results
	tensor_cmp = np.zeros(tensor_ref.shape)

	acc_coord = 0

	# Change each coordinate of reference geometry in turn
	# Write altered mol file and run rsp calculation
	# Read resulting tensor and accumulate
	for i in range(len(coords)):

		for j in range(3):

			if (stencil_np == 2):

				new_coords = copy.deepcopy(coords)

				# Make positive displacement, write altered mol file, do rsp calculation
				new_coords[i][j] += d
				write_mol(fname_mol_chg, basis_set, num_atomtypes, num_atoms_per_type, charges_per_type, new_coords)
				tensor_p1 = do_rsp_calc(fname_mol_chg, fname_dal, fname_bin, basdir)

				# Step down twice to negative displacement
				new_coords[i][j] -= 2.0*d
				write_mol(fname_mol_chg, basis_set, num_atomtypes, num_atoms_per_type, charges_per_type, new_coords)
				tensor_m1 = do_rsp_calc(fname_mol_chg, fname_dal, fname_bin, basdir)

				# Put num diff result in comparison tensor
				tensor_cmp[acc_coord:acc_coord+1,:] = (tensor_p1/2.0 - tensor_m1/2.0)/d

				acc_coord +=1

			elif (stencil_np == 7):

				new_coords = copy.deepcopy(coords)

				# Make 3x positive displacement, write altered mol file, do rsp calculation
				new_coords[i][j] += 3.0 *d
				write_mol(fname_mol_chg, basis_set, num_atomtypes, num_atoms_per_type, charges_per_type, new_coords)
				tensor_p3 = do_rsp_calc(fname_mol_chg, fname_dal, fname_bin, basdir)

				# Walk down displacements in succession for rest of stencil
				new_coords[i][j] -= d
				write_mol(fname_mol_chg, basis_set, num_atomtypes, num_atoms_per_type, charges_per_type, new_coords)
				tensor_p2 = do_rsp_calc(fname_mol_chg, fname_dal, fname_bin, basdir)

				new_coords[i][j] -= d
				write_mol(fname_mol_chg, basis_set, num_atomtypes, num_atoms_per_type, charges_per_type, new_coords)
				tensor_p1 = do_rsp_calc(fname_mol_chg, fname_dal, fname_bin, basdir)

				# Jump two steps here to skip the undisplaced
				new_coords[i][j] -= 2.0*d
				write_mol(fname_mol_chg, basis_set, num_atomtypes, num_atoms_per_type, charges_per_type, new_coords)
				tensor_m1 = do_rsp_calc(fname_mol_chg, fname_dal, fname_bin, basdir)

				new_coords[i][j] -= d
				write_mol(fname_mol_chg, basis_set, num_atomtypes, num_atoms_per_type, charges_per_type, new_coords)
				tensor_m2 = do_rsp_calc(fname_mol_chg, fname_dal, fname_bin, basdir)

				new_coords[i][j] -= d
				write_mol(fname_mol_chg, basis_set, num_atomtypes, num_atoms_per_type, charges_per_type, new_coords)
				tensor_m3 = do_rsp_calc(fname_mol_chg, fname_dal, fname_bin, basdir)

				# Put num diff result in comparison tensor
				tensor_cmp[acc_coord:acc_coord+1,:] = (tensor_p3/60.0 - tensor_p2*(3.0/20.0) + tensor_p1*(3.0/4.0) - tensor_m1*(3.0/4.0) + tensor_m2*(3.0/20.0) - tensor_m3/60.0)/(d)

				acc_coord +=1

			else:

				print('ERROR: Stencil extent ', stencil_np, ' not supported')

	tensor_diff = tensor_ref - tensor_cmp

	return np.amax(tensor_ref), np.amax(abs(tensor_diff)), tensor_ref, tensor_cmp, tensor_diff
